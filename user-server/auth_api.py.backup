from fastapi import FastAPI, HTTPException, Depends
from pydantic import BaseModel
from typing import Optional
from sqlalchemy.orm import Session
from db import get_db, User
from email_utils import send_email_code
import jwt
import random

app = FastAPI()

SECRET_KEY = "your_jwt_secret_key"
ALGORITHM = "HS256"

# 注册模型
class RegisterRequest(BaseModel):
    email: str
    password: str
    nickname: str
    gender: Optional[str] = "male"  # 默认为男性

# 验证模型
class VerifyRequest(BaseModel):
    email: str
    code: str

# 登录模型
class LoginRequest(BaseModel):
    email: str
    password: str

# 通用返回模型
class TokenResponse(BaseModel):
    token: str
    message: str

# 用户信息返回模型
class UserInfoResponse(BaseModel):
    email: str
    nickname: str
    height: Optional[int] = None
    weight: Optional[int] = None
    avatar_url: Optional[str] = None
    gender: str = "male"  # 添加性别字段

# 更新用户信息请求模型
class UpdateUserInfoRequest(BaseModel):
    token: str
    height: Optional[int] = None
    weight: Optional[int] = None
    avatar_url: Optional[str] = None
    # 注意：性别不包含在更新请求中，因为性别不可修改

# 注册接口
@app.post("/register")
def register(request: RegisterRequest, db: Session = Depends(get_db)):
    # 检查邮箱唯一
    existing = db.query(User).filter_by(email=request.email).first()
    if existing:
        raise HTTPException(status_code=400, detail="邮箱已注册")

    # 检查 nickname 唯一
    existing_nick = db.query(User).filter_by(nickname=request.nickname).first()
    if existing_nick:
        raise HTTPException(status_code=400, detail="昵称已被使用")

    # 验证性别值
    if request.gender not in ["male", "female"]:
        raise HTTPException(status_code=400, detail="性别值无效，必须是male或female")

    # 生成 6 位验证码
    code = str(random.randint(100000, 999999))
    success = send_email_code(request.email, code)
    if not success:
        raise HTTPException(status_code=500, detail="验证码发送失败")

    # 插入数据库，包含性别信息
    user = User(
        email=request.email,
        password=request.password,
        verification_code=code,
        verified=False,
        nickname=request.nickname,
        gender=request.gender
    )
    db.add(user)
    db.commit()
    db.refresh(user)

    # 创建用户专属模型目录
    import os
    model_dir = os.path.join("/root/model-server/generated_models", f"{user.nickname}_models")
    os.makedirs(model_dir, exist_ok=True)

    return {"message": "注册成功，验证码已发送至邮箱"}

# 验证邮箱验证码
@app.post("/verify")
def verify(request: VerifyRequest, db: Session = Depends(get_db)):
    user = db.query(User).filter_by(email=request.email).first()
    if not user:
        raise HTTPException(status_code=404, detail="用户不存在")

    if user.verification_code != request.code:
        raise HTTPException(status_code=400, detail="验证码错误")

    user.verified = True
    db.commit()
    return {"message": "验证成功"}

# 登录接口 - 修改token生成逻辑，包含nickname和gender
@app.post("/login", response_model=TokenResponse)
def login(request: LoginRequest, db: Session = Depends(get_db)):
    user = db.query(User).filter_by(email=request.email, password=request.password).first()
    if not user:
        raise HTTPException(status_code=401, detail="邮箱或密码错误")
    if not user.verified:
        raise HTTPException(status_code=403, detail="邮箱未验证")

    # 在token中包含用户ID、邮箱、昵称和性别
    token_payload = {
        "user_id": user.id,
        "email": user.email,
        "nickname": user.nickname,
        "gender": user.gender
    }
    token = jwt.encode(token_payload, SECRET_KEY, algorithm=ALGORITHM)
    return TokenResponse(token=token, message="登录成功")

# 获取用户信息接口
@app.get("/user_info")
def get_user_info(token: str, db: Session = Depends(get_db)):
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        user_id = payload.get("user_id")
        
        user = db.query(User).filter_by(id=user_id).first()
        if not user:
            raise HTTPException(status_code=404, detail="用户不存在")
        
        return {
            "email": user.email,
            "nickname": user.nickname,
            "height": getattr(user, "height", None),
            "weight": getattr(user, "weight", None),
            "avatar_url": getattr(user, "avatar_url", None),
            "gender": getattr(user, "gender", "male")  # 添加性别字段
        }
    except jwt.PyJWTError:
        raise HTTPException(status_code=401, detail="无效的token")

# 更新用户信息接口
@app.post("/update_user_info")
def update_user_info(request: UpdateUserInfoRequest, db: Session = Depends(get_db)):
    try:
        payload = jwt.decode(request.token, SECRET_KEY, algorithms=[ALGORITHM])
        user_id = payload.get("user_id")
        
        user = db.query(User).filter_by(id=user_id).first()
        if not user:
            raise HTTPException(status_code=404, detail="用户不存在")
        
        # 更新用户信息（不包括昵称和性别，因为它们不可改变）
        if request.height is not None:
            user.height = request.height
        if request.weight is not None:
            user.weight = request.weight
        if request.avatar_url is not None:
            user.avatar_url = request.avatar_url
            
        db.commit()
        return {"message": "用户信息更新成功"}
    except jwt.PyJWTError:
        raise HTTPException(status_code=401, detail="无效的token") 